% !TeX spellcheck = en_US
\documentclass[a4paper]{report}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{subfig}
%\usepackage{lipsum}
\usepackage{verbatim}
\usepackage[table,xcdraw]{xcolor}
\geometry{a4paper,top=2.5cm,bottom=2.5cm,left=3cm,right=3cm,%
	heightrounded,bindingoffset=5mm}

\usepackage{color}
\usepackage{listings}
\usepackage{xcolor}

\usepackage{color}
\usepackage{listings}
\lstset{ %
	language=Java,                % choose the language of the code
	basicstyle=\footnotesize,       % the size of the fonts that are used for the code
	numbers=left,                   % where to put the line-numbers
	numberstyle=\footnotesize,      % the size of the fonts that are used for the line-numbers
	stepnumber=1,                   % the step between two line-numbers. If it is 1 each line will be numbered
	numbersep=5pt,                  % how far the line-numbers are from the code
	backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
	showspaces=false,               % show spaces adding particular underscores
	showstringspaces=false,         % underline spaces within strings
	showtabs=false,                 % show tabs within strings adding particular underscores
	frame=single,           % adds a frame around the code
	tabsize=2,          % sets default tabsize to 2 spaces
	captionpos=b,           % sets the caption-position to bottom
	breaklines=true,        % sets automatic line breaking
	breakatwhitespace=false,    % sets if automatic breaks should only happen at whitespace
	escapeinside={\%*}{*)}          % if you want to add a comment within your code
}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

\begin{document}
	\begin{titlepage}
		\begin{center}
			
			% Top 
			\includegraphics[width=0.45\textwidth]{img/unipi.png}~\\[2.5cm]
			
			
			% Title
			\HRule \\[0.4cm]
			{ \LARGE 
				\textbf{Intent Based Application}\\[0.4cm]
				\emph{Group Project Report for Advanced Network Architectures And Wireless Systems}\\[0.4cm]
			}
			\HRule \\[1.5cm]
			
			
			
			% Author
			{ \large
				Francesco Iemma \\[0.1cm]
				Yuri Mazzuoli \\[0.1cm]
				Giovanni Menghini \\[0.1cm]
			}
			
			\vfill
			
			\textsc{\large M.Sc. in Computer Engineering}\\[0.4cm]
			
			
			% Bottom
			{\large Academic Year 2021/22}
			
		\end{center}
	\end{titlepage}
	
	
	\tableofcontents
	\newpage
	
	\chapter*{Introduction}
	This project is aimed to design and develop an intent based application. The scenario is the following: \textit{"Consider a set of clients that can communicate through a redundant network
	(e.g., based on a spine-leaf topology.) An external application can request to install paths
	between host pairs, by just specifying the endpoint identifiers, we refer to this as an
	host-2-host intent. The network has to allow communications only among the specified host
	pairs. Moreover, the network has to automatically reconfigure in case of link failures.
	Design and realize a system that allows users to request and withdraw host-to-host intents,
	and configures the underlying network accordingly."}

	
	\noindent The objectives of the projects are:
	\begin{enumerate}
		\item \textit{"Implement a Floodlight module that exposes a RESTful interface allowing clients to create/delete host-to-host instents. The module will then dynamically install and update flow rules in the network to allow the communication among specified pairs. Possible path switches must occur transparently to clients."}
		
		\item \textit{"Test the overall system using Mininet and Floodlight, devising proper scenarios to demonstrate the above functionalities."}
	\end{enumerate}
	
	
	\chapter{Implementation}
	\noindent The objective of the intent based application is mainly to expose a REST interface to allow the request of an \textbf{intent}. An \textbf{intent} is a request, done by an host, to have a link with another host, this link must tolerate link failures.
	\noindent Hence the controller must implement a module that is in charge of:
	\begin{itemize}
		\item Computing the best path between hostA and hostB
		\item Installing in the switches of the network the proper rules to establish this path
		\item Being responsive in case of a link failures and establishing a new path to maintain the link alive
	\end{itemize}
	\noindent In the implementation of the application we have re-used some Floodlight modules extending some classes where needed. In the following sections we will analyze the choices done and the classes extended in order to implement the features shown previously.
	
	\section{Floodlight Functionalities}
	\subsection{How To Compute A Path: Routing Service}
	\noindent Floodlight by default exposes a REST inteface to retrieve a path between a source (switch DPID and port ID) and a destination (switch DPID and port ID).
	
	\noindent The computation of the path is given from the method \textit{getPath(srcDpid, srcPort, dstDpid, dstPort)} of the class implementing the interface \textit{IRoutingService}\footnote{net.floodlightcontroller.routing.IRoutingService}.
	
	\noindent Thus the idea is to reuse this function in order to retrieve the path between hostA and hostB.
	
	\subsection{How To Install A Path: Forwarding Base}
	\noindent Once we have the path we need to install it inside the switches of the network in order to have the path established and working.
	
	\noindent To do so Floodlight provides the abstract class ForwardingBase\footnote{net.floodlightcontroller.routing.ForwardingBase} which is in charge of implementing a forwarding module. The forwarding module "is responsible for programming flows to a switch in response to a policy decision". The implementation of the abstract class must implement the following abstract method:
	
	\begin{lstlisting}[language=Java]
		public abstract Command processPacketInMessage(IOFSwitch sw, OFPacketIn pi, 
		IRoutingDecision decision, FloodlightContext cntx);
	\end{lstlisting}
	
	
	\noindent The Floodlight standard implementation of this abstract class is the class Forwarding\footnote{net.floodlightcontroller.forwarding.Forwarding}.
	
	\section{Floodlight Extended Forwarding Module}\label{forwarding}
	\noindent Thus the idea is to extend Forwarding and redefine the method processPacketInMessage which is in charge of defining what the module must do when a packetIn arrives.
	
	\noindent In our scenario the operations that must be performed when a packetIn arrives are:
	\begin{itemize}
		\item Retrieving the path using the method \textit{getPath(..)} provided by IRoutingService
		\item Installing the path using the method \textit{PushRoute(..)} inherited by this module from ForwardingBase
	\end{itemize}
	\noindent It is important to underline that before doing so, the logic of the method must check if the packetIn arriving is due to the packet coming from the hostA that has asked the intent and that has as destination the hostB indicated in the intent.
	
	\noindent To do this check it is needed a data structure that is in charge of maintaining the list of intent asked and established.
	
	\section{REST API For Establishing An Intent}
	\noindent When the hostA wants to send an intent to make a connection with hostB it has to use the REST API. This API is provided by the classes: IntentWebRoutable, AddNewIntent, DelIntent and GetIntent; these classes use methods from IntentForwarding.
	
	\noindent When the REST API receives the intent, it establishes it inserting an entry in a dedicated data structure where it is indicated:
	\begin{itemize}
	\item The Source
	\item The Destination
	\item Intent Timeout
	\end{itemize}

	\noindent The possible API’s that we can use are:
        \begin{itemize}
        \item "/addNewIntent/json", that is used to insert new intent. This API gets from a JSON file two IPs (representing source and destination) and a timeout. This use the addNewIntent function of the IntentForwarding class that, first check if new intent is already presents, then in case it isn’t put it in intentDb that is an ArrayList of HostPair. Moreover, this function also set the timeout time of the pair.
        \item "/delIntent/json", that takes from a JSON file two IPs and a timeout and removes the intent corresponding to them. To do this, it use the delIntent function of IntentForwarding, that iterates the intentDB list and removes the intent with IPs passed in through JSON.
	\item "/getIntents/json", that is used to get all intents present in specific moment. It use the getIntents function of IntentForwarding that simply return intentDb.
        \end{itemize}

	
	
	\noindent Then the intent will be pushed in the network when the source host tries to send a packet to the destination host. When this happens a packetIn sending from the first switch that receives the packet will be sent to the controller and will be handled by the forwarding module seen in \ref{forwarding}
	
	\section{Responsiveness To Link Failures \& Topology Changes}
	To be responsiveness to topology changes we can exploit the ITopologyListener inteface. In fact in the Floodligh documentation for the TopologyService it is written: \textit{"All the information about the current topology is stored in an immutable data structure called the topology instance. If there is any change in the topology, a new instance is created and the topology changed notification message is called. If other modules want to listen for changes in topology they can implement the ITopologyListener interface."}\footnote{https://floodlight.atlassian.net/wiki/spaces/floodlightcontroller/pages/1343623/TopologyService+Dev}.
	
	\noindent Thus we can implement a class that implements ITopologyListener and that each time a topology change arrives it recompute the paths of intent involved in the topology change (i.e. the ones that has a link which doesn't work anymore). To do so we can use the TopologyInstance (updated before sending the notification message that the topology has changed) to understand which intent are involved in the topology change.
	
	\chapter{Testing}
	\include{testing.tex}
\end{document}
